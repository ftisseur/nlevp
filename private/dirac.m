function [coeffs,fun,F] = dirac(N,N1,alpha,kappa)
%DIRAC    QEP from Dirac operator.
%  [COEFFS,FUN,F] = nlevp('dirac',N,N1,ALPHA,KAPPA) generates the
%  coefficient matrices of a quadratic matrix polynomial
%  lambda^2*A + lambda*B + C of dimension N.  The spectrum
%  of this matrix polynomial is the second order spectrum of the
%  Dirac operator with an electric Coulombic potential, relative
%  to the subspace generated by the Hermite functions of odd order.
%  The potential is attractive and of strength ALPHA where
%  -SQRT(3)/2 < ALPHA < 0.
%  The constant KAPPA (which should be an integer) corresponds
%  to a radially symmetric decomposition of the space into partial wave
%  subspaces.  In this decomposition, the operator acts on
%  L^2(0,\infty)xL^2(0,\infty). The matrix truncation is found by
%  picking N1 Hermite functions in the first component and N - N1 in the
%  second component.
%  By default N = 80, N1 = floor(N/2) , KAPPA = -1, and ALPHA = -1/2.
%  Requires N >= N1 >= 0.
%  The matrices are returned in a cell array: COEFFS = {C, B, A}.
%  FUN is a function handle to evaluate the monomials 1,lambda,lambda^2
%  and their derivatives.
%  F is the function handle C + lambda*B + lambda^2*A.
%  This problem has the properties pep, qep, real, symmetric,
%  parameter-dependent, scalable.

%  Reference:
%  L. Boulton and N. Boussaid, Non-variational computation of the
%  eigenstates of Dirac operators with radially symmetric potentials, 
%  LMS J. Comput. Math., 13:10-32, 2010.

if nargin < 1 || isempty(N)
    N = 80;
else
    warning('NLEVP:truescale',['Note that the scale parameter N ',...
        'now targets the true dimension of the problem'])
end
if nargin < 2 || isempty(N1), N1 = floor(N/2); end
if nargin < 3 || isempty(alpha), alpha = -1/2; end
if nargin < 4 || isempty(kappa), kappa = -1; end

if N1<0, error('N1 must be >= 0'); end
N2 = N-N1;
if N2<0, error('N must be >= N1'); end

% Assemble matrices
mn = max(N1,N2);
[R2,R3,R4,R5,R6] = R23456mat(mn,mn);
A1 = [eye(N1)+alpha*R3(1:N1,1:N1),       R2(1:N1,1:N2)+kappa*R3(1:N1,1:N2);
    -R2(1:N2,1:N1)+kappa*R3(1:N2,1:N1), -eye(N2)+alpha*R3(1:N2,1:N2)     ];
A2 = [eye(N1)+2*alpha*R3(1:N1,1:N1)+alpha^2*R6(1:N1,1:N1)+R4(1:N1,1:N1)+...
        kappa*(R5(1:N1,1:N1)+R5(1:N1,1:N1)')+kappa^2*R6(1:N1,1:N1),...
    -R2(1:N1,1:N2)-R2(1:N2,1:N1)'+alpha*(R5(1:N1,1:N2)-R5(1:N2,1:N1)')+...
        2*alpha*kappa*R6(1:N2,1:N1)';
    -R2(1:N2,1:N1)-R2(1:N1,1:N2)'-alpha*(R5(1:N2,1:N1)-R5(1:N1,1:N2)')+...
        2*alpha*kappa*R6(1:N2,1:N1),...
    eye(N2)-2*alpha*R3(1:N2,1:N2)+alpha^2*R6(1:N2,1:N2)'+R4(1:N2,1:N2)-...
        kappa*(R5(1:N2,1:N2)+R5(1:N2,1:N2)')+kappa^2*R6(1:N2,1:N2)];

% Symmetrize (already symmetric up to roundoff).
A2  =  (A2 + A2')/2; A1 = (A1 + A1')/2;

coeffs = {A2,-2*A1,eye(N)};
fun = @(lam) nlevp_monomials(lam,2);
F =  nlevp_handleQEP(coeffs);

end

function [R2,R3,R4,R5,R6] = R23456mat(m,n)
% Shared variables.
mn = max(m,n);
pm = ones(1,mn);pm(2:2:end) = -1;
l = 1:mn-1;
ll = 0:mn-1;
p = [1,cumprod( ones(1,mn-1)+ones(1,mn-1)./l/2 )];
sq = sqrt(p);

R2 = (-4)/sqrt(pi)*(pm(1:m)'*pm(1:n))...
    .*(ll(1:m)'*ones(1,n)-ones(m,1)*ll(1:n))...
    ./(2*ll(1:m)'*ones(1,n)-2*ones(m,1)*ll(1:n)-ones(m,n))...
    ./(2*ll(1:m)'*ones(1,n)-2*ones(m,1)*ll(1:n)+ones(m,n))...
    .*(sq(1:m)'*sq(1:n));

R3 = (-2)/sqrt(pi)*(pm(1:m)'*pm(1:n))...
    .*cumsum(((p(1:m)./(2*ll(1:m)+1))'*ones(1,n))...
               ./(2*ll(1:m)'*ones(1,n)-2*ones(m,1)*ll(1:n)-ones(m,n)))...
    .*((1./sq(1:m))'*sq(1:n));

d0 = (4*ll+3)/2;
d1 = -sqrt((2*ll+1).*(2*ll))/2;
d1 = d1(2:mn);
R4 = diag(d1,1)+diag(d1,-1)+diag(d0);
R4 = R4(1:m,1:n);

R5 = triu(2*(pm(1:m)'*pm(1:n)) .* (sq(1:m)'*(1./sq(1:n))),1)+eye(m,n);

R6 = triu(2*(pm'*pm) .* (sq'*(1./sq)),1);
R6 = R6+R6'+2*eye(mn);
R6 = R6(1:m,1:n);
end
